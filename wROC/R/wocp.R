#' Optimal cut-off points for complex survey data
#'
#' Calculate optimal cut-off points for complex survey data (Iparragirre et al., 2022).
#' Some functions of the package OptimalCutpoints (Lopez-Raton et al, 2014) have been used and modified in order them to consider sampling weights.
#'
#' @param response.var Vector with information of the response variable
#' or character string with the name of the variable
#' indicating the response variable in the data set.
#' @param phat.var Vector with information of the estimated probabilities
#' or character string with the name of the variable
#' indicating these probabilities in the data set.
#' @param weights.var Vector with information of the sampling weights
#' or character string with the name of the variable
#' indicating the sampling weights in the data set.
#' If \code{NULL}, the sampling design should be specified in the argument \code{design}.
#' For unweighted estimates, set all the sampling weight values to 1.
#' @param tag.event Label indicating the event of interest in \code{response.var}.
#' The default option is \code{tag.event = NULL}, which selects the class with the lowest number of units.
#' @param tag.nonevent Label indicating the non-event in \code{response.var}.
#' The default option is \code{tag.nonevent = NULL}, which selects the class with the greatest number of units.
#' @param method Choose one of the following methods (Lopez-Raton et al, 2014) to obtain the optimal cut-off point:
#' `MaxProdSpSe`, `ROC01`, `Youden`, `MaxEfficiency`
#' @param data Data frame which must incorporate information on the columns
#' \code{response.var}, \code{phat.var} and \code{weights.var}.
#' If \code{data=NULL}, then specific numerical vectors must be included in
#' \code{response.var}, \code{phat.var} and \code{weights.var}
#' or the sampling design should be indicated in the argument \code{design}.
#' @param design An object of class \code{survey.design} generated by
#' \code{survey::svydesign} indicating the complex sampling design of the data.
#' If \code{NULL} information on the data and weights must be included in the argument
#' \code{data} or as a vector in the argument \code{weights.var}.
#'
#'
#' @references Iparragirre, A., Barrio, I., Aramendi, J. and Arostegui, I. (2022). Estimation of cut-off points under complex-sampling design data. \emph{SORT-Statistics and Operations Research Transactions} \bold{46}(1), 137--158.
#' @references Lopez-Raton, M., Rodriguez-Alvarez, M.X, Cadarso-Suarez, C. and Gude-Sampedro, F. (2014). OptimalCutpoints: An R Package for Selecting Optimal Cutpoints in Diagnostic Tests. \emph{Journal of Statistical Software} \bold{61}(8), 1--36.
#'
#' @returns an object of class `wocp`. This object is a list that contains information about the method used to calculate the optimal cut-off point, the optimal value of the cut-off point and the corresponding value of the selected optimality criterion, as well as all the cut-off points considered and the corresponding values of the criterion.
#'
#' @export
#'
#' @examples
#' data(example_data_wroc)
#'
#' myocp <- wocp(response.var = "y", phat.var = "phat", weights.var = "weights",
#'               tag.event = 1, tag.nonevent = 0,
#'               method = "Youden",
#'               data = example_data_wroc)
#'
#'# Or equivalently
#' myocp <- wocp(example_data_wroc$y, example_data_wroc$phat, example_data_wroc$weights,
#'               tag.event = 1, tag.nonevent = 0, method = "Youden")
#'
#'
wocp <- function(response.var, phat.var, weights.var = NULL,
                 tag.event = NULL, tag.nonevent = NULL,
                 method = c("Youden", "MaxProdSpSe", "ROC01", "MaxEfficiency"),
                 data = NULL, design = NULL){

  if(missing(method) || is.null(method)) {
    stop("'method' argument required.")
  }
  if(any(!(method %in% c("MaxProdSpSe","ROC01","Youden","MaxEfficiency")))) {
    stop ("You have entered an invalid method.")
  }

  if (missing(phat.var)|| is.null(phat.var)) {
    stop("'phat.var' argument required.")
  }
  if (missing(response.var)|| is.null(response.var)) {
    stop("'response.var' argument required.")
  }

  if(inherits(response.var, "character")){
    response.var <- data[,response.var]
  }

  if(length(table(response.var))!=2){stop("Response variable must have two classes.")}

  if(inherits(phat.var, "character")){
    phat.var <- data[,phat.var]
  }

  if(inherits(weights.var, "character")){
    weights.var <- data[,weights.var]
  }

  if(!is.null(design)){
    data <- get(design$call$data)
    weights <- as.character(design$call$weights[2])
    weights.var <- data[,weights]
  }

  if(length(response.var) != length(phat.var) || length(response.var) != length(weights.var)){
    stop("Vectors indicating the responses, predicted probabilities and sampling weights must be the same length.")
  }

  # Missing tags:
  if(is.null(tag.nonevent)){
    if(is.null(tag.event)){
      tag.nonevent <- names(table(response.var)[which.max(table(response.var))])
      tag.event <- names(table(response.var)[which.min(table(response.var))])
    } else {
      tags <- names(table(response.var))
      tag.other <- which(tags == tag.event)
      tag.nonevent <- tags[-tag.other]
    }
  } else {
    if(is.null(tag.event)){
      tags <- names(table(response.var))
      tag.other <- which(tags == tag.nonevent)
      tag.event <- tags[-tag.other]
    }
  }

  res <- list()
  res$optimal.cutoff <- list()
  res$optimal.cutoff$method <- method

  pop.prev <- sum(weights.var[which(response.var != tag.nonevent)])/sum(weights.var)
  cutoffs <- sort(unique(phat.var))
  sew.v <- sapply(lapply(cutoffs, wse, response.var = response.var, tag.event = tag.event, phat.var = phat.var, weights.var = weights.var), "[[", 1)
  spw.v <- sapply(lapply(cutoffs, wsp, response.var = response.var, tag.nonevent = tag.nonevent, phat.var = phat.var, weights.var = weights.var), "[[", 1)

  # Optimal cut-off point calculation:
  criterion.v <- criterion.function(method = method, pop.prev = pop.prev, se.v = sew.v, sp.v = spw.v)
  opt.ocp <- optimize.criterion(method = method, criterion.v = criterion.v, se.v = sew.v, sp.v = spw.v, cutoffs = cutoffs)

  res <- list()

  res$tags <- list(tag.event = as.character(tag.event),
                   tag.nonevent = as.character(tag.nonevent))
  res$basics <- list(n.event = length(which(response.var==tag.event)),
                     n.nonevent = length(which(response.var==tag.nonevent)),
                     hatN.event = sum(weights.var[which(response.var==tag.event)]),
                     hatN.nonevent = sum(weights.var[which(response.var==tag.nonevent)]))

  res$optimal.cutoff <- list()
  res$optimal.cutoff$method <- method
  res$optimal.cutoff$optimal <- opt.ocp$optimal
  res$optimal.cutoff$all <- opt.ocp$all

  res$call <- match.call()

  class(res) <- "wocp"

  return(res)

}
