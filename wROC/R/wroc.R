#' Estimation of the ROC curve of logistic regression models with complex survey data
#'
#' Calculate the ROC curve of a logistic regression model
#' considering sampling weights with complex survey data
#' @param response.var Vector with information of the response variable
#' or character string with the name of the variable
#' indicating the response variable in the data set.
#' @param phat.var Vector with information of the estimated probabilities
#' or character string with the name of the variable
#' indicating these probabilities in the data set.
#' @param weights.var Vector with information of the sampling weights
#' or character string with the name of the variable
#' indicating the sampling weights in the data set.
#' If \code{NULL}, the sampling design should be specified in the argument \code{design}.
#' For unweighted estimates, set all the sampling weight values to 1.
#' @param tag.event Label indicating the event of interest in \code{response.var}.
#' The default option is \code{tag.event = NULL}, which selects the class with the lowest number of units.
#' @param tag.nonevent Label indicating the non-event in \code{response.var}.
#' The default option is \code{tag.nonevent = NULL}, which selects the class with the greatest number of units.
#' @param data Data frame which must incorporate information on the columns
#' \code{response.var}, \code{phat.var} and \code{weights.var}.
#' If \code{data=NULL}, then specific numerical vectors must be included in
#' \code{response.var}, \code{phat.var} and \code{weights.var}
#' or the sampling design should be indicated in the argument \code{design}.
#' @param design An object of class \code{survey.design} generated by
#' \code{survey::svydesign} indicating the complex sampling design of the data.
#' If \code{NULL} information on the data and weights must be included in the argument
#' \code{data} or as a vector in the argument \code{weights.var}.
#' @param cutoff.method Method to be used for calculating the optimal cut-off point.
#' If `cutoff.method = NULL`, then no optimal cut-off point is drawn.
#' If an optimal cut-off point is to be drawn, one of the following methods needs to be selected:
#' `Youden`, `MaxProdSpSe`, `ROC01`, `MaxEfficiency`.
#'
#' @return all the values for sensitivity and specificity parameters used to plot the curve, the value of the area under the curve (AUC), as well as, information about the optimal cut-off point are available.
#'
#' @export
#'
#'
#' @examples
#' data(example_data_wroc)
#'
#' mycurve <- wroc(response.var = "y", phat.var = "phat", weights.var = "weights",
#'                 data = example_data_wroc,
#'                 tag.event = 1, tag.nonevent = 0,
#'                 cutoff.method = "Youden")
#'
#' # Or equivalently
#' mycurve <- wroc(response.var = example_data_wroc$y,
#'                 phat.var = example_data_wroc$phat,
#'                 weights.var = example_data_wroc$weights,
#'                 tag.event = 1, tag.nonevent = 0,
#'                 cutoff.method = "Youden")
#'
wroc <- function(response.var, phat.var, weights.var = NULL,
                 tag.event = NULL, tag.nonevent = NULL,
                 data = NULL, design = NULL,
                 cutoff.method = NULL){

  if(inherits(response.var, "character")){
    response.var <- data[,response.var]
  }

  if(length(table(response.var))!=2){stop("Response variable must have two classes.")}

  if(inherits(phat.var, "character")){
    phat.var <- data[,phat.var]
  }

  if(inherits(weights.var, "character")){
    weights.var <- data[,weights.var]
  }

  if(!is.null(design)){
    data <- get(design$call$data)
    weights <- as.character(design$call$weights[2])
    weights.var <- data[,weights]
  }

  if(length(response.var) != length(phat.var) || length(response.var) != length(weights.var)){
    stop("Vectors indicating the responses, predicted probabilities and sampling weights must be the same length.")
  }

  # Missing tags:
  if(is.null(tag.nonevent)){
    if(is.null(tag.event)){
      tag.nonevent <- names(table(response.var)[which.max(table(response.var))])
      tag.event <- names(table(response.var)[which.min(table(response.var))])
    } else {
      tags <- names(table(response.var))
      tag.other <- which(tags == tag.event)
      tag.nonevent <- tags[-tag.other]
    }
  } else {
    if(is.null(tag.event)){
      tags <- names(table(response.var))
      tag.other <- which(tags == tag.nonevent)
      tag.event <- tags[-tag.other]
    }
  }


  all.phat <- sort(unique(phat.var))

  lower <- all.phat[1:(length(all.phat)-1)]
  upper <- all.phat[2:length(all.phat)]
  cutoffs <- rev(c(0, (lower+upper)/2, 1))

  # ROCw curve:
  sew.v <- sapply(lapply(cutoffs, wse, response.var = response.var, tag.event = tag.event, phat.var = phat.var, weights.var = weights.var), "[[", 1)
  spw.v <- sapply(lapply(cutoffs, wsp, response.var = response.var, tag.nonevent = tag.nonevent, phat.var = phat.var, weights.var = weights.var), "[[", 1)

  res <- list()
  res$wroc.curve <- list(Sew.values = sew.v, Spw.values = spw.v, cutoffs = cutoffs)

  # Area under the ROCw curve:
  #auc <- wauc(response.var, phat.var, weights.var, tag.event, tag.nonevent, data)
  lc <- length(cutoffs)
  auc <- sum(spw.v[-lc]*sew.v[-1]-spw.v[-1]*sew.v[-lc])/2
  res$wauc <- auc

  # Cut-off point:
  if(!is.null(cutoff.method)){
    if(any(!(cutoff.method %in% c("MaxProdSpSe","ROC01","Youden","MaxEfficiency")))) {
      stop ("You have entered an invalid method.", call. = FALSE)
    }
    ocp <- wocp(response.var = response.var, phat.var = phat.var,
                weights.var=weights.var,
                tag.nonevent=tag.nonevent,
                method=cutoff.method)
    res$optimal.cutoff$method <- cutoff.method
    res$optimal.cutoff$cutoff.value <- ocp[["optimal.cutoff"]][["optimal"]][["cutoff"]]
    res$optimal.cutoff$Spw <- ocp[["optimal.cutoff"]][["optimal"]][["Spw"]]
    res$optimal.cutoff$Sew <- ocp[["optimal.cutoff"]][["optimal"]][["Sew"]]
  }

  # Output object:
  res$tags <- list()
  res$tags$tag.event <- as.character(tag.event)
  res$tags$tag.nonevent <- as.character(tag.nonevent)
  res$basics <- list()
  res$basics$n.event <- length(which(response.var==tag.event))
  res$basics$n.nonevent <- length(which(response.var==tag.nonevent))
  res$basics$hatN.event <- sum(weights.var[which(response.var==tag.event)])
  res$basics$hatN.nonevent <- sum(weights.var[which(response.var==tag.nonevent)])
  res$call <- match.call()

  class(res) <- "wroc"

  return(res)

}
